#include <iostream>
#include <vector>
#include <algorithm> // 이 헤더 파일에 'lower_bound'라는 핵심 도구가 들어있습니다.

using namespace std;

int main() {
    // 1. 입출력 속도 최적화 (백준 등 알고리즘 문제 풀 때 필수)
    // C언어의 입출력 버퍼와 C++의 입출력 버퍼 동기화를 끊어서 속도를 높입니다.
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    // 입력을 받습니다. 만약 입력이 없으면 종료합니다.
    if (!(cin >> N)) return 0;

    // 2. 족보(LIS) 벡터 선언
    // 이 벡터는 '실제 정답 수열'이 아니라, '길이별로 가장 유리한 끝값'을 저장합니다.
    // lis[i] = "길이가 i+1인 증가 수열 중 가장 작은 끝 숫자"
    vector<int> lis; 

    // N번 반복하며 숫자를 하나씩 확인합니다.
    for (int i = 0; i < N; ++i) {
        int num;
        cin >> num; // 현재 스테이지의 숫자를 하나 받습니다.

        // 3. 가장 큰 숫자보다 더 큰 숫자가 들어왔을 때 (단순 추가)
        // case A: 족보가 비어있거나 (첫 시작)
        // case B: 족보의 맨 마지막 숫자(현재까지 만든 가장 긴 수열의 끝)보다 지금 숫자가 더 클 때
        if (lis.empty() || lis.back() < num) {
            lis.push_back(num); // 족보의 맨 뒤에 붙입니다. (수열의 길이가 1 늘어남)
        } 
        
        // 4. 중간에 낄 수 있는 숫자가 들어왔을 때 (교체/갱신)
        // 지금 들어온 num이 족보의 맨 끝 값보다는 작습니다.
        // 그렇다면 이 num은 족보의 어딘가에 있는 숫자를 '더 작은 값'으로 대체해서
        // 미래의 가능성을 높여줄 수 있습니다.
        else {
            // lower_bound: lis 배열 안에서 'num 이상인 값'이 처음 나오는 위치(주소)를 찾습니다.
            // 이분 탐색(Binary Search)을 사용하기 때문에 속도가 매우 빠릅니다. (log N)
            auto it = lower_bound(lis.begin(), lis.end(), num);
            
            // 찾은 위치의 값을 num으로 덮어씌웁니다.
            // 예: 족보가 [1, 5, 10] 인데 num이 6이라면?
            // 10 자리에 6이 들어갑니다 -> [1, 5, 6]
            // "길이 3짜리 수열을 만드는데 10으로 끝나는 것보다 6으로 끝나는 게 훨씬 유리해!"라는 뜻입니다.
            *it = num; 
        }
    }

    // 5. 결과 출력
    // 최종적으로 족보(lis)의 크기가 우리가 만들 수 있는 가장 긴 수열의 길이가 됩니다.
    cout << lis.size() << endl;

    return 0;
}